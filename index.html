<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>新水的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="新水的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="新水的个人博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="新水的个人博客">
<meta property="og:description" content="新水的个人博客">
<meta property="og:locale">
<meta property="article:author" content="新水">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="新水的个人博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">新水的个人博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-常见的SaaS系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/04/%E5%B8%B8%E8%A7%81%E7%9A%84SaaS%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-02-03T16:31:55.000Z" itemprop="datePublished">2024-02-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%89%AB%E7%9B%B2/">扫盲</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/04/%E5%B8%B8%E8%A7%81%E7%9A%84SaaS%E7%B3%BB%E7%BB%9F/">常见的SaaS系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="ERP（Enterprise-Resource-Planning）系统："><a href="#ERP（Enterprise-Resource-Planning）系统：" class="headerlink" title="ERP（Enterprise Resource Planning）系统："></a>ERP（Enterprise Resource Planning）系统：</h2><blockquote>
<p>ERP系统是一种综合性的企业管理软件系统，用于集成和管理企业的不同业务功能，包括财务管理、物流管理、供应链管理、生产管理、销售与客户关系管理等。通过ERP系统，企业可以实现各个部门之间的信息共享和协作，提高业务流程的效率和准确性。</p>
</blockquote>
<h2 id="CRM（Customer-Relationship-Management）系统："><a href="#CRM（Customer-Relationship-Management）系统：" class="headerlink" title="CRM（Customer Relationship Management）系统："></a>CRM（Customer Relationship Management）系统：</h2><blockquote>
<p>CRM系统是一种用于管理和维护客户关系的软件系统，旨在帮助企业增强与客户的互动和沟通，提高客户满意度和忠诚度。CRM系统可以帮助企业进行客户数据的收集和分析、销售管道管理、售后服务管理等，以提供更好的客户体验和增加销售机会。</p>
</blockquote>
<h2 id="sCRM（Social-Customer-Relationship-Management）"><a href="#sCRM（Social-Customer-Relationship-Management）" class="headerlink" title="sCRM（Social Customer Relationship Management）"></a>sCRM（Social Customer Relationship Management）</h2><blockquote>
<p>是一种以社交媒体为基础的客户关系管理方法和系统。sCRM致力于利用社交媒体平台上的信息和交互，改善企业与客户之间的关系，并提供更个性化、实时的客户服务和支持。</p>
</blockquote>
<p>sCRM系统主要包括以下功能：</p>
<ol>
<li>社交媒体监测和分析：通过监测社交媒体平台上关于企业品牌、产品、服务的讨论和反馈，了解客户的需求和偏好，以及评估企业形象的声誉。</li>
<li>社交媒体参与和互动：通过社交媒体平台与客户进行实时互动，回答客户的咨询和问题，提供个性化的解决方案和服务。还可以利用社交媒体平台进行促销活动和客户关怀，提高客户满意度和忠诚度。</li>
<li>社交媒体营销和推广：利用社交媒体平台进行品牌宣传和产品推广，通过有针对性的广告和宣传活动，吸引客户的注意力，增加品牌曝光度和销售机会。</li>
<li>社交媒体分析和报告：通过社交媒体平台的数据分析和报告工具，评估社交媒体活动的效果和影响力，了解市场趋势和竞争情报。</li>
</ol>
<p>sCRM的目标是通过社交媒体的力量，与客户建立更紧密和更有效的关系，增强客户参与和忠诚度，并提供更好的客户体验和满意度。sCRM系统为企业提供了一个综合管理客户关系的工具，使企业能够更好地应对不断变化的社交媒体环境和客户行为。</p>
<h2 id="SRM（Supplier-Relationship-Management）系统："><a href="#SRM（Supplier-Relationship-Management）系统：" class="headerlink" title="SRM（Supplier Relationship Management）系统："></a>SRM（Supplier Relationship Management）系统：</h2><blockquote>
<p>SRM系统是一种用于管理和维护供应商关系的软件系统，旨在帮助企业与供应商进行有效的合作和协调。SRM系统通常涵盖供应商选择与评估、采购管理、供应商合同管理、供应商绩效评估等功能，以提高供应链的效率和可靠性。</p>
</blockquote>
<p>HRP（Human Resource Planning）系统：</p>
<blockquote>
<p>HRP系统是一种用于人力资源管理的软件系统，旨在帮助企业有效管理和规划人力资源。HRP系统包括员工信息管理、招聘与入职管理、培训与发展管理、绩效管理、薪酬管理等功能，以支持企业的人力资源策略和决策。</p>
</blockquote>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/02/04/%E5%B8%B8%E8%A7%81%E7%9A%84SaaS%E7%B3%BB%E7%BB%9F/" data-id="cls6ao08400006wugclbefkqu" data-title="常见的SaaS系统" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-认识Iaas与PasS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/04/%E8%AE%A4%E8%AF%86Iaas%E4%B8%8EPasS/" class="article-date">
  <time class="dt-published" datetime="2024-02-03T16:28:49.000Z" itemprop="datePublished">2024-02-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%89%AB%E7%9B%B2/">扫盲</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/04/%E8%AE%A4%E8%AF%86Iaas%E4%B8%8EPasS/">认识Iaas与PasS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Iaas"><a href="#Iaas" class="headerlink" title="Iaas"></a>Iaas</h2><blockquote>
<p>IaaS（基础设施即服务）：用户可以在云服务提供商提供的基础设施上部署和运行任何软件，包括操作系统和应用软件。用户没有权限管理和访问底层的基础设施，但是有权管理操作系统、存储内容，可以安装管理应用程序，甚至是有权管理网络组件。</p>
</blockquote>
<p>提供按需快速配置虚拟化硬件基础架构资源，如服务器，存储和网络</p>
<p>Iaas是更底层的基础设施，既然提供了基础设施，一般云计算平台会基于基础设施提供平台服务，而无须用户管理底层的基础设施，这就是Paas。</p>
<h2 id="PaaS"><a href="#PaaS" class="headerlink" title="PaaS"></a>PaaS</h2><blockquote>
<p>PaaS（平台即服务）：用户可以使用由云服务提供商支持的编程语言、库、服务以及开发工具来创建、开发应用程序并部署在相关的基础设施上。无需管理底层的基础设施，包括网络、服务器，操作系统或者存储。只能控制部署在基础设施中操作系统上的应用程序，配置应用程序所托管的环境的可配置参数。<br>提供平台软件或中间件执行环境的按需快速配置，例如消息队列，<a target="_blank" rel="noopener" href="https://www.alibabacloud.com/zh/knowledge/what-is-relational-database">关系型数据库</a>管理系统和<a target="_blank" rel="noopener" href="https://www.alibabacloud.com/zh/knowledge/what-is-containerization">容器编排</a>系统。</p>
</blockquote>
<h2 id="aPaaS"><a href="#aPaaS" class="headerlink" title="aPaaS"></a>aPaaS</h2><blockquote>
<p><em>应用程序平台即服务 (aPaaS) 允许您在云中构建、部署和运行自定义应用程序。以下是如何选择能够为您的组织提供最大价值的 aPaaS 解决方案。</em><br>aPaaS（应用程序平台即服务）是指任何基于云的服务，使最终用户能够在云中构建、部署和运行自定义应用程序。它将 SaaS（软件即服务）的云体验与 IaaS（基础设施即服务）的应用程序开发工具结合起来。<br>aPaaS 不应与 PaaS（平台即服务）混淆，后者指的是基于云的中间件的所有变体。 PaaS 包括 Amazon Web Services 和 Azure 等大规模服务，而 aPaaS 的范围较窄，仅描述专注于实现快速应用程序开发的 PaaS 平台。<br>aPaaS 开发是独一无二的，因为它将应用程序生命周期的所有阶段（构建、测试、部署、管理和更新）集中在一个可以从任何地方安全访问的单一平台中。过去，应用程序平台必须通过各种单独的服务按需部署，但有了 aPaaS，就无需将不同的元素拼凑成一个工作系统。</p>
</blockquote>
<h3 id="并非所有-aPaaS-解决方案都是一样的"><a href="#并非所有-aPaaS-解决方案都是一样的" class="headerlink" title="并非所有 aPaaS 解决方案都是一样的"></a>并非所有 aPaaS 解决方案都是一样的</h3><p>aPaaS 解决方案通常分为三种主要类型：云、低代码或无代码。<br>云包括 Salesforce 和 ServiceNow 等大型套件。这些选项具有很多功能，但它们需要专门的资源和复杂的构建。由于云提供商附带的复杂代码很容易陷入停滞，因此对于希望随意构建、定制、更改和部署的企业来说，这并不是最灵活的选择。<br><strong>低代码和无代码 aPaaS 解决方案通常被归为一组</strong>，因为它们都允许您以更少的基础设施问题和可视化方法构建应用程序。事实上，两者有很大不同。虽然两者都有助于更快的启动速度，但它们针对的是完全不同的用户需求。<br>低代码通过自动生成代码来提高开发团队的生产力。无代码还可以提高生产力，但它是通过完全删除代码库并完全依赖拖放界面来实现的。这允许业务用户直接参与开发过程，从而使开发人员能够将更多时间集中在待办事项中最复杂的任务上。</p>
<h3 id="为什么无代码是正确的选择"><a href="#为什么无代码是正确的选择" class="headerlink" title="为什么无代码是正确的选择"></a>为什么无代码是正确的选择</h3><p>很容易想象任何给定的 aPaaS 解决方案如何让生活变得更轻松，但选择错误的解决方案仍然会让您陷入复杂的遗留维护和漫长的开发时间表。大型云提供商可能很笨重，并且需要专门的技能才能充分发挥其潜力。尽管低代码解决方案需要较少的编码，但应用程序仍然需要由工程师进行配置，这会产生不可避免的遗留维护成本。<br>在评估 aPaaS 平台时，<a target="_blank" rel="noopener" href="https://www.unqork.com/resources/articles/welcome-to-the-era-of-no-code-in-the-enterprise">无代码</a>可能是最明智的选择。它速度快、易于配置且易于更新。尽管绕过了传统编码固有的大部分复杂性，无代码仍然使您能够构建复杂、强大的应用程序。如果您正在寻找一种方法来缩小 IT 技能差距、满足消费者的高需求并构建具有任意数量所需功能的应用程序，<a target="_blank" rel="noopener" href="https://www.unqork.com/resources/articles/7-questions-to-determine-if-your-enterprise-is-ready-for-no-code-platform">那么无代码就是您的最佳选择</a>。<br>想了解更多吗？你可以：</p>
<ul>
<li><p>参加<a target="_blank" rel="noopener" href="https://www.unqork.com/form/codeless-guidebook">无代码导览，</a>深入探讨工作流程的全可视化创建、<a target="_blank" rel="noopener" href="https://www.unqork.com/form/codeless-guidebook">新应用程序与第三方</a><a target="_blank" rel="noopener" href="https://www.unqork.com/form/codeless-guidebook">和遗留系统</a>的 无缝集成 ，以及<a target="_blank" rel="noopener" href="https://www.unqork.com/form/codeless-guidebook">大规模品牌数字体验</a><a target="_blank" rel="noopener" href="https://www.unqork.com/form/codeless-guidebook">的创建 。</a> **</p>
</li>
<li><p>阅读<a target="_blank" rel="noopener" href="https://www.unqork.com/form/codeless-guidebook">权威无代码指南，</a>了解 无代码架构、它的工作原理、谁已经在使用它以及它是否适合您的组织。</p>
</li>
</ul>
<h2 id="SaaS"><a href="#SaaS" class="headerlink" title="SaaS"></a>SaaS</h2><blockquote>
<p>通过Web向消费者提供应用程序或软件服务。 SaaS不要求消费者管理底层平台和基础架构。电子邮件服务，数据备份服务和SMS服务是SaaS的示例。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/726477/1706751995829-add46989-c26e-46ef-819d-7a4bdb28acd0.png#averageHue=%232292a4&clientId=u77e96b60-4c07-4&from=paste&id=u46a1984e&originHeight=1451&originWidth=2306&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=ua92893d4-1f39-4a29-ad42-9b5ac00c142&title="></p>
<h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><blockquote>
<h2 id="如何在IaaS，PaaS和SaaS之间进行选择？"><a href="#如何在IaaS，PaaS和SaaS之间进行选择？" class="headerlink" title="如何在IaaS，PaaS和SaaS之间进行选择？"></a>如何在IaaS，PaaS和SaaS之间进行选择？</h2><h3 id="选择IaaS"><a href="#选择IaaS" class="headerlink" title="选择IaaS:"></a>选择IaaS:</h3><ul>
<li>当您需要灵活控制<a target="_blank" rel="noopener" href="https://www.alibabacloud.com/zh/knowledge/what-is-virtualization">虚拟化硬件</a>时</li>
<li>当您需要控制应用程序的操作系统时</li>
</ul>
<h3 id="选择PaaS"><a href="#选择PaaS" class="headerlink" title="选择PaaS:"></a>选择PaaS:</h3><ul>
<li>当您不打算安装平台软件或中间件和底层操作系统时</li>
<li>当您不打算管理和维护底层中间件和操作系统时</li>
</ul>
<h3 id="选择SaaS"><a href="#选择SaaS" class="headerlink" title="选择SaaS:"></a>选择SaaS:</h3><ul>
<li>当您需要具有即用型应用程序或软件而无需管理底层堆栈时</li>
</ul>
</blockquote>
<h2 id="低代码-无代码"><a href="#低代码-无代码" class="headerlink" title="低代码&amp;无代码"></a>低代码&amp;无代码</h2><p>低代码是一种应用开发方法论，旨在加速应用程序的开发过程。低代码平台提供了可视化的开发工具和组件库，使开发者能够通过简单的拖拽和配置，而不是编写大量的代码，来构建应用程序。低代码平台还提供了一些预置的基础功能和自动化工具，如数据模型、用户界面生成器和工作流引擎等，以帮助开发者更快速地构建应用程序</p>
<p><em>纵观工程史，开发人员一直试图将机器代码抽象为人类可以轻松理解的东西。无代码最终提供了终极抽象，使任何人都可以成为工程师。</em></p>
<p>想象一下您是一位想要开设银行账户的消费者。如果幸运的话，您可能会选择一家允许您通过移动或网络应用程序提交申请的银行。当您填写此内容时，您可能没有太多考虑企业创建此应用程序并将其交付给您的幕后发生的事情。但如果你这样做，大多数时候你可能会想到代码。那么，代码到底是什么？这些年来它是如何发展的？</p>
<h3 id="代码的概念"><a href="#代码的概念" class="headerlink" title="代码的概念"></a>代码的概念</h3><p>如果我们从概念上考虑编码，总体目标就是将想法或动作转换为机器可以读取的内容。虽然概念很简单，但现实需要学习复杂的语法才能有效地与计算机对话。<br>尽管编码变得越来越重要，但令人惊讶的事实是很少有人能够真正用机器理解的语言进行读写。据估计，美国有<a target="_blank" rel="noopener" href="https://www.daxx.com/blog/development-trends/number-software-developers-world">400 万人</a>会编程，而劳动力中的这一数字超过 1.32 亿。这意味着只有大约 3% 的工作人口能够将自己的想法转化为应用——这一现实使得具有宝贵洞察力的工人无法充分参与这一过程。<br>随着时间的推移，计算机工程师通过抽象代码并使之更接近自然语言来弥补机器语言的复杂性。通过这样做，他们逐渐可以使用更好地弥合机器语言和人类语言之间差距的编程语言来简化软件开发过程。<br>但为了充分理解编码瓶颈，追溯编程语言多年来的发展和抽象是有帮助的。从早期的机器代码到高级编程语言，计算机工程师一直在寻找改进我们构建软件的方式的方法。最终，这条时间线让我们看到了无代码的出现，它提供了机器语言的终极抽象，并完全重新定义了工程师的含义。<br><em>*<em>与我们的一位行业专家一起</em>***安排 **</em><a target="_blank" rel="noopener" href="https://www.unqork.com/c/request-demo?utm_content=blog-demo-text">个性化的虚拟无代码演示。</a></p>
<h4 id="机器代码时代"><a href="#机器代码时代" class="headerlink" title="机器代码时代"></a>机器代码时代</h4><p>机器代码是计算机的本机语言，不需要转换机器就可以理解。二进制（0 和 1）的概念是机器代码的基础，由 Gottfried Leibniz 在 17 世纪末提出。用机器代码编程需要人类记住数字代码和复杂的修改才能与计算机交互。结果，几乎没有人直接用机器代码进行编程。</p>
<h4 id="低级编程语言时代"><a href="#低级编程语言时代" class="headerlink" title="低级编程语言时代"></a>低级编程语言时代</h4><p>低级编程语言（也称为汇编语言）提供机器代码的初始抽象级别。这些语言使用字母数字助记码而不是二进制来为计算机提供可理解的指令。<br>然而，为了使计算机能够理解汇编语言，工程师需要开发将汇编语言翻译成机器代码的计算机程序。这些汇编程序最初是在 20 世纪 50 年代和 1960 年代为 TX-0 和 PDP-1 等计算机编写的，提供了一种在机器代码和更容易被人类阅读的较短描述性单词之间进行协调的快速方法。</p>
<h4 id="高级编程语言时代"><a href="#高级编程语言时代" class="headerlink" title="高级编程语言时代"></a>高级编程语言时代</h4><h4 id="第一代高级编程语言"><a href="#第一代高级编程语言" class="headerlink" title="第一代高级编程语言"></a>第一代高级编程语言</h4><p>编码发展的下一步是向高级编程语言发展。凭借 1957 年的 FORTRAN 和 1959 年的 COBOL，计算机工程师使用更自然的语言元素，向以人类交谈的方式进行编程又迈进了一步。这些语言的第一代使用编译器将其翻译回机器代码，这本身就带来了性能损失。然而，这些语言让更多的人学习如何编程，激发了第一波大规模的编码学术兴趣。</p>
<h4 id="第二代高级编程语言"><a href="#第二代高级编程语言" class="headerlink" title="第二代高级编程语言"></a>第二代高级编程语言</h4><p>随着 1983 年的 C++、1991 年的 Python 和 1993 年的 Ruby，第二代高级编程语言进一步简化了编码过程。开发人员意识到，以前的编程语言中存在可重复的操作，这些操作可以而且应该自动化。通过这样做，与第一代高级编程语言相比，它们可以加速和简化整个编码过程。</p>
<h4 id="构架"><a href="#构架" class="headerlink" title="构架"></a>构架</h4><p>框架使用预先存在的高级编程语言作为其核心基础，但随后实现了所谓的护栏以提高效率。 2005 年开发的 Ruby on Rails 就是一个例子。Ruby on Rails 等框架在特定用例（例如 Web 应用程序开发）中表现出色，尽管程序员为了提高效率而放弃了其他高级编程语言的灵活性。工作范围有限。</p>
<h4 id="低代码"><a href="#低代码" class="headerlink" title="低代码"></a>低代码</h4><p>虽然高级编程语言代表着机器代码及其低级对应语言向前迈出的一大步，但对于开发人员来说，它们仍然是一个耗时的过程。最近，低代码平台的出现有助于进一步自动化开发，提供可视化配置界面，为用户提供编程语言。从那里，工程师在必要时编辑和改进生成的代码库。<br>低代码平台的缺点是它们在技术上仍然使用代码——这意味着应用程序开发的任务仍然仅限于一小部分人。这也意味着，就像它的前辈一样，低代码也会产生相关的遗留成本——维护仍然需要由受过经典培训、知道如何编码的工程师来完成。</p>
<h4 id="无代码时代"><a href="#无代码时代" class="headerlink" title="无代码时代"></a>无代码时代</h4><p>最后，无代码提供了一种全新的前进方式。通过将代码完全抽象为完全可视化的界面，用户可以依赖组件来构建应用程序。机器代码和人类开发之间的最后一层翻译意味着任何具有有价值（并且可能改变游戏规则）想法的人都可以尝试构建软件。<br>最终，无代码是我们一直在等待实现的真正的抽象。无代码使我们能够使用自然的人类语言来创建现代世界所需的应用程序，所有这些都以比以往更快、更具成本效益的方式进行。通过投资无代码并让这些平台为我们将想法转化为代码，任何人都可以成为程序员。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.alibabacloud.com/zh/knowledge/difference-between-iaas-paas-saas">Saas&#x2F;Paas&#x2F;IaaS区别</a></li>
<li><a target="_blank" rel="noopener" href="https://www.unqork.com/resources/blog-articles/what-is-apaas">什么是aPaaS</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/02/04/%E8%AE%A4%E8%AF%86Iaas%E4%B8%8EPasS/" data-id="cls6ao08f00036wug8bn9av3g" data-title="认识Iaas与PasS" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-费曼学习法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/05/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2024-01-05T07:42:37.000Z" itemprop="datePublished">2024-01-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/">生活杂记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/05/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/">费曼学习法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>费曼学习法（Feynman Learning Technique）是一种学习和提高思维能力的方法，它基于物理学家理查德·费曼（Richard Feynman）的学习方式和思维方式。</p>
<p>费曼学习法的步骤如下：</p>
<p>选择一个主题： 选择你要学习的主题或概念。</p>
<p>以教学方式学习： 将你要学习的内容以教学的方式呈现给一个想象中的学生。使用简单的语言和通俗的方式解释概念，使用图表、例子和比喻来帮助理解。</p>
<p>发现知识的空缺： 当你试图教授这个主题时，你会发现对某些概念或细节缺乏理解。注意这些不足之处，并记录下来。</p>
<p>回到学习资料： 当你发现理解不足之处时，回到学习资料，重新学习和填补这些空缺。这可以是教科书、文章、视频教程等。</p>
<p>简化和回顾： 用自己的话再次解释给学生。简化问题，使用通俗易懂的语言来回顾所学内容。如果你无法用简单的话解释清楚，那就说明你对该概念理解还不够深入。</p>
<p>通过费曼学习法，你可以深入理解所学内容，并通过尝试向他人解释来发现自己知识不足的地方。这个过程不仅可以帮助你加深学习，还可以提高你的思维能力和表达能力。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/05/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/" data-id="clr0bxihu00008wug0szo2x12" data-title="费曼学习法" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-常用的算法技巧" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/05/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/" class="article-date">
  <time class="dt-published" datetime="2024-01-05T03:42:11.000Z" itemprop="datePublished">2024-01-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/05/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/">常用的算法技巧</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>最近重新温习了一下算法，总结了一些常用的算法技巧。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><h3 id="分而治之（D-C）"><a href="#分而治之（D-C）" class="headerlink" title="分而治之（D&amp;C）"></a>分而治之（D&amp;C）</h3><p>快速排序就是参考这个思想。工作原理是：</p>
<ol>
<li>找出简单的基线条件</li>
<li>确定如何缩小问题的规模，使其符合技术条件，典型的分土地问题，基数条件是长是宽的倍数。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">试着用分而治之的思想，来理解快速排序。 快速排序的基线条件是数组为空或者只包含一个，这种情况下，只需要返回数组，根本就不用排序。首先，我们从数组中选择一个元素，这个元素被称为基准值（pivot）。</span><br><span class="line"></span><br><span class="line">接下来，我们找出比基准值小的元素以及比基准值大的元素，这被称为分区（partitioning）。现在我们有：</span><br><span class="line">（1）一个小于所有基准值的数组组成的子数组</span><br><span class="line">（2）基准值</span><br><span class="line">（3）一个由所有大于基准值的数字组成的子数组</span><br><span class="line">这时，子数组是无序的，如果子数组有序，则排序就成功了。于是我们递归对子数组进行排序，最后把数组合并就是有序的数组了。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="常用排序"><a href="#常用排序" class="headerlink" title="常用排序"></a>常用排序</h3><ol>
<li>选择排序，性能低</li>
<li>快速排序<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    public static void quickSort(int[] nums, int left, int right) &#123;</span><br><span class="line">        if (left &gt;= right) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = left;</span><br><span class="line">        int base = nums[mid], l = left, r = right;</span><br><span class="line">        while (l != r) &#123;</span><br><span class="line">            // 从右边往左边检索,当右边的数小于基数时，停止</span><br><span class="line">            while (base &lt;= nums[r] &amp;&amp; l &lt; r) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            // 从左边往右边检索,当左边的数大于基数时，停止</span><br><span class="line">            while (nums[l] &lt;= base &amp;&amp; l &lt; r) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            //这里表示找到右边有小于基数的，左边有大于基数的，因此交换位置</span><br><span class="line">            int temp = nums[r];</span><br><span class="line">            nums[r] = nums[l];</span><br><span class="line">            nums[l] = temp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        // 当代码执行到这里时，把基数和中点的数交换位置</span><br><span class="line">        nums[left] = nums[l];</span><br><span class="line">        nums[l] = base;</span><br><span class="line">        // 分治法，继续排序基数左边的</span><br><span class="line">        quickSort(nums, left, l - 1);</span><br><span class="line">        // 分治法，继续排序基数右边的</span><br><span class="line">        quickSort(nums, l + 1, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h3 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h3><h3 id="狄克斯特拉算法"><a href="#狄克斯特拉算法" class="headerlink" title="狄克斯特拉算法"></a>狄克斯特拉算法</h3><h3 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h3><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/05/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/" data-id="clr0983rm00008ougej0b0omj" data-title="常用的算法技巧" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-搜索常用技巧" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/03/%E6%90%9C%E7%B4%A2%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="article-date">
  <time class="dt-published" datetime="2024-01-03T04:01:24.000Z" itemprop="datePublished">2024-01-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/03/%E6%90%9C%E7%B4%A2%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">搜索常用技巧</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li>搜索完全匹配的结果<br> 为词语加商英文””</li>
<li>从结果中排除<br> -，例如 spring -csdn</li>
<li>组合运算符<br> 北京|上海 人口 北京OR上海 人口</li>
<li>通配符<br> 如 李*杰</li>
<li>搜索社交媒体<br> 如 @Martin</li>
<li>搜索特定文件<br> filetype:pdf 红楼梦</li>
<li>搜索特定网站<br> site:baidu.com python spring -site:csdn.com</li>
<li>查找标题中带有特定词语的网页<br> intitle:pyhone -site:csdn</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/03/%E6%90%9C%E7%B4%A2%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" data-id="clqx9guku00000wugdp7ve6m8" data-title="搜索常用技巧" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-两数之和" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/30/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/" class="article-date">
  <time class="dt-published" datetime="2023-12-30T07:32:40.000Z" itemprop="datePublished">2023-12-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/30/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/">两数之和</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target的那两个整数，并返回它们的数组下标。</span><br><span class="line"></span><br><span class="line">你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</span><br><span class="line"></span><br><span class="line">你可以按任意顺序返回答案。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><html>
<head>
    
<pre><code>        class Solution &#123;
            public static int[] twoSum(int[] nums, int target) &#123;
                HashMap&lt;Integer, Integer&gt; subs = new HashMap&lt;&gt;();
                // 1.存起来每个数字的下标
                for (int i = 0; i &lt; nums.length; i++) &#123;
                    subs.put(nums[i], i);
                &#125;
        
                // 2.遍历数组，如果有匹配的值，则取出他的下标
                for (int i = 0; i &lt; nums.length; i++) &#123;
                    int sub2 = target - nums[i];
                    Integer index = subs.get(sub2);
                    if (index != null &amp;&amp; index != i) &#123;
                        int[] result = new int[2];
                        result[0] = i;
                        result[1] = subs.get(sub2);
                        return result;
                    &#125;
                &#125;
                return null;
            &#125;
        &#125;
</code></pre>
</head>
</html>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/12/30/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/" data-id="clqrr0wuj0000g8ug3de02l6a" data-title="两数之和" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据中台是什么" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/25/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E6%98%AF%E4%BB%80%E4%B9%88/" class="article-date">
  <time class="dt-published" datetime="2023-12-25T09:40:46.000Z" itemprop="datePublished">2023-12-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/">数据开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/25/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E6%98%AF%E4%BB%80%E4%B9%88/">数据中台是什么</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>最近有空，打算整理一下关于数据的想法。</p>
<h2 id="一、数据质量的评估"><a href="#一、数据质量的评估" class="headerlink" title="一、数据质量的评估"></a>一、数据质量的评估</h2><ul>
<li>数据的完整性</li>
<li>数据的准确性</li>
<li>数据的一致性</li>
<li>数据的规范性</li>
<li>数据的时效性</li>
</ul>
<h2 id="二、数据中台"><a href="#二、数据中台" class="headerlink" title="二、数据中台"></a>二、数据中台</h2><h3 id="2-1-数据中台化的概念"><a href="#2-1-数据中台化的概念" class="headerlink" title="2.1 数据中台化的概念"></a>2.1 数据中台化的概念</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据中台化就是建设元数据中心、数据指标中心、数仓模型中心、数据资产中心等数据工具的过程，数据中台化的目的是建立统一的数据服务中心和自主分析平台，规范数据的统一出口，从而提升整体数据服务的交付效率和研发速度，解决企业发展过程中由于数据量的激增与业务的扩大而出现的口径不一致、重复开发、指标开发需求响应慢、数据质量低、数据成本高等问题。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-2-元数据中心"><a href="#2-2-元数据中心" class="headerlink" title="2.2 元数据中心"></a>2.2 元数据中心</h3><pre><code>元数据中心是数据中台最基础的系统，是所有数据中台系统的基石，后续的数仓开发、指标开发、数据治理、成本治理等都需要元数据中心的支持，主要包括数据整合、数据管理、数据地图三大模块。
</code></pre>
<ul>
<li>数据整合：需要能够直充不太的结构化数据，比如Mysql,Hive,Oracle等，还需要能够支持半结构的数据，比如Kafka、Redis、Hbase等，并且需要考虑不同数据源的不同集群。</li>
<li>数据管理：就是管理数据中台所有的元数据，元数据即描述数据的数据。分类主要有数据属性、数据字典、数据血缘（Druid）、数据评估、数据优化等。</li>
<li>数据地图：是基于所有元数据搭建起来的数据资产列表</li>
</ul>
<h3 id="2-3-数据指标中心"><a href="#2-3-数据指标中心" class="headerlink" title="2.3 数据指标中心"></a>2.3 数据指标中心</h3><p>概念： 数据指标中心是规范化开发指标并对其进行管理和维护的系统，包括主题域归纳、派生指标、统计口径、规范命名等的管理</p>
<h3 id="2-4-数仓模型中心"><a href="#2-4-数仓模型中心" class="headerlink" title="2.4 数仓模型中心"></a>2.4 数仓模型中心</h3><ul>
<li>控制数据源</li>
<li>划分主题域</li>
<li>构建一致性维度</li>
<li>构建总线矩阵</li>
<li>数据分层建设:ODS、CDM(DIM、DWD、DWS)、ADS</li>
<li>数仓效果评估（规范度、完善度、复用度）</li>
</ul>
<h3 id="2-5-数据资产中心"><a href="#2-5-数据资产中心" class="headerlink" title="2.5 数据资产中心"></a>2.5 数据资产中心</h3><h5 id="数据资产定级"><a href="#数据资产定级" class="headerlink" title="数据资产定级"></a>数据资产定级</h5><ul>
<li>建设全链路数据资产通路</li>
<li>制定数据资产等级标准</li>
<li>数据资产等级打标</li>
</ul>
<h4 id="数据资产质量治理"><a href="#数据资产质量治理" class="headerlink" title="数据资产质量治理"></a>数据资产质量治理</h4><h4 id="数据资产成本治理"><a href="#数据资产成本治理" class="headerlink" title="数据资产成本治理"></a>数据资产成本治理</h4><h3 id="2-6-数据服务中心"><a href="#2-6-数据服务中心" class="headerlink" title="2.6 数据服务中心"></a>2.6 数据服务中心</h3><h4 id="将数据写入查询库"><a href="#将数据写入查询库" class="headerlink" title="将数据写入查询库"></a>将数据写入查询库</h4><p>数据中台加工出来的数据都是以数仓表为主的，一般在数据开发完成后，需要将数据输出到不同的查询库中，比如实时数仓HBase、离线数据Mysql、Redis等。</p>
<p>框架简介</p>
<p><strong>Hadoop</strong>：Apache Hadoop是大数据处理的核心框架，它提供了分布式文件系统（HDFS）和批处理计算框架（MapReduce）。Hadoop可以分布式存储和处理大量数据，并提供高可靠性和容错能力。</p>
<p><strong>HDFS</strong>：Hadoop分布式文件系统（HDFS）是Hadoop的一个模块，用于存储大量数据。HDFS将数据分布在多个机器上，并提供高吞吐量的访问，存储框架(Hadoop Distributed FileSystem)</p>
<p><strong>HBase</strong>：HBase是一个分布式、可扩展的、面向列的NoSQL数据库。它在Hadoop上建立了一个分布式数据库，用于存储和处理大量结构化数据，适用于快速读写结构化数据。</p>
<p><strong>Hive</strong>：Apache Hive是基于Hadoop的数据仓库基础架构，提供了一种类似于SQL的查询语言（HiveQL）来处理和查询大数据。Hive将SQL查询转换为MapReduce任务，并以批处理方式进行处理，(使用 Hadoop 作为存储引擎，并且仅运行在 HDFS )。</p>
<p><strong>Spark</strong>：Apache Spark是一个快速、通用的大数据处理框架，提供了高级API，支持分布式数据处理和机器学习。Spark具有比Hadoop更快的速度，并且提供了交互式查询、流处理和图处理等功能。</p>
<p><strong>MaxCompute</strong>：MaxCompute是阿里云提供的一种大数据处理框架，用于批量计算、流式计算和交互式查询。MaxCompute提供了高可扩展性、高可靠性和高性能的计算能力。</p>
<p><strong>Hologres</strong>：Hologres是一个云原生的大数据实时分析数据库，它集成了流数据计算和传统OLAP数据分析，能够实现高并发的实时数据查询和分析</p>
<p>可以将这些框架按照功能进行分类，列举如下：</p>
<h4 id="大数据框架梳理"><a href="#大数据框架梳理" class="headerlink" title="大数据框架梳理"></a>大数据框架梳理</h4><p><strong>存储框架</strong>：<br>HDFS(Hadoop Distributed FileSystem) HBase</p>
<p><strong>计算框架</strong>：<br>MapReduce（Hadoop） Spark MaxCompute</p>
<p><strong>数据查询与分析框架</strong>：<br>Hive(使用 Hadoop 作为存储引擎，并且仅运行在 HDFS ) Spark MaxCompute Hologres</p>
<p>Hive和Spark是两个在大数据处理和分析领域中非常常用的框架，它们都提供了数据查询和分析的能力，但在一些方面有一些差异。</p>
<p>处理模型：Hive是基于SQL的查询引擎，它将SQL查询转换为MapReduce任务进行处理，因此适合用于离线批处理任务。而Spark是一个通用的大数据处理引擎，支持批处理、交互式查询、流式处理和机器学习等多种计算模型，可以更快地处理数据。</p>
<p>性能：由于Spark使用了内存计算和优化的执行引擎，相对于Hive而言速度更快。Spark的内存计算能力使其在迭代计算和复杂计算场景下表现更出色。</p>
<p>用户友好性：Hive是建立在Hadoop生态系统上的，使用HiveQL作为查询语言，与传统的关系型数据库SQL语法基本相同，使得熟悉SQL的开发人员更容易上手。而Spark的编程接口和语言更加丰富，可以使用Scala、Java、Python和R等多种语言编写程序。</p>
<p>实时处理：Spark支持流式计算，可以进行实时的数据流处理，而Hive主要适用于离线批处理任务。如果需要处理实时数据，Spark更适合。</p>
<p>根据实际需求和数据处理场景的不同，可以选择使用Hive或Spark，有时也可以将它们结合起来使用，灵活选择最合适的工具来处理和分析数据。</p>
<p>从功能上来看，可以将它们归为以下几类：</p>
<p><strong>分布式存储框架</strong>：HDFS和HBase都是用于存储大量数据的分布式文件系统，但HDFS主要用于存储大文件，而HBase则适用于快速读写结构化数据。</p>
<p><strong>批处理计算框架</strong>：MapReduce是Hadoop的批处理计算框架，而Spark和MaxCompute也都可以进行批处理计算。它们都适合处理大规模数据集，但Spark和MaxCompute相对于MapReduce提供了更高的性能和更友好的编程接口。</p>
<p><strong>数据查询与分析框架</strong>：Hive、Spark、MaxCompute和Hologres都提供了对大数据进行查询和分析的能力。它们都支持类似于SQL的查询语言，但在处理能力、性能和可扩展性等方面有一些差异。</p>
<p>需要根据具体的需求和场景选择适合的框架。例如，如果需要进行存储和批处理计算，可以选择HDFS和MapReduce；如果需要进行实时数据查询和分析，可以选择Hive、Spark、MaxCompute或Hologres。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/12/25/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E6%98%AF%E4%BB%80%E4%B9%88/" data-id="clqkxqmlp0005q0ugh0s6cgm5" data-title="数据中台是什么" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0/" rel="tag">数据中台</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-java实现一个简单的令牌桶" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/25/java%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BB%A4%E7%89%8C%E6%A1%B6/" class="article-date">
  <time class="dt-published" datetime="2023-12-25T08:20:18.000Z" itemprop="datePublished">2023-12-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/25/java%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BB%A4%E7%89%8C%E6%A1%B6/">java实现一个简单的令牌桶</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>java实现一个简单的令牌桶，（不考虑机器时间之间的差异）</p>
<pre><code>package tool.tokenBucket;
import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisPool;

import java.util.Arrays;

public class RateLimiter &#123;

private static JedisPool jedisPool;

public TokenBucket build(String key, int capacity, double rate) &#123;
    return new TokenBucket(key, capacity, rate);
&#125;

public static class TokenBucket &#123;
    /**
     * 指定的桶
     */

    private String tokenKey;
    /**
     * 指定的容量
     */
    private int capacity;
    /**
     * 指定的速率/秒
     */
    private double rate;

    public TokenBucket(String key, int capacity, double rate) &#123;
        this.tokenKey = key;
        this.capacity = capacity;
        this.rate = rate;
    &#125;

    /**
     * LUA脚本
     * local capacity= tonumber(ARGV[1])
     * local rate=tonumber(ARGV[2])
     * local now =tonumber(redis.call(&#39;time&#39;)[1])
     * local tokens = tonumber(redis.call(&#39;get&#39;， KEYS[1]) or 0)
     * local modify_time = tonumber(redis.call(&#39;get&#39;, KEYS[2]) or
     * &lt;p&gt;
     * if tokens &lt;capacity then
     *    local delta= math.min(rate * (now - modify_ time),capacity-tokens)
     *    if delta &gt;=1 then
     *      tokens = tokens + delta
     *      redis.call(&#39;set&quot;，KEYS[2],now)
     *      redis.call(&#39;set&quot;,KEYS[1], tokens)
     *    end
     *end
     *
     *
     *if tokens &gt;= 1 then
     *    redis.call(&#39;set&#39;,KEYS[1],tokens -1)
     *    return 1
     *else
     *    return 0
     *end
     */
    /**
     * 思路：
     * 1. 首先，获取指定桶的token
     * 2.判断当前桶的token是否小于指定的最大容量，则按照速率生成令牌（速率需要用当前时间与修改时间对比），得到一个值delta，若delta大于1，则生成令牌，并且不允许超过最大容量capacity，把生成的token设置到当前桶，并存储修改时间
     * 3.如果当前桶的令牌数大于1时，减去一个令牌，表示申请令牌成功，返回1 否则失败
     */
    String script =
            &quot;    local capacity= tonumber(ARGV[1])\n&quot; +
            &quot;    local rate=tonumber(ARGV[2])\n&quot; +
            &quot;    local now =tonumber(redis.call(&#39;time&#39;)[1])\n&quot; +
            &quot;    local tokens = tonumber(redis.call(&#39;get&#39;， KEYS[1]) or 0)\n&quot; +
            &quot;    local modify_time = tonumber(redis.call(&#39;get&#39;, KEYS[2]) or\n&quot; +
            &quot;\n&quot; +
            &quot;if tokens &lt;capacity then \n&quot; +
            &quot;        local delta= math.min(rate * (now - modify_ time),capacity-tokens)\n&quot; +
            &quot;        if delta &gt;=1 then\n&quot; +
            &quot;        tokens = tokens + delta\n&quot; +
            &quot;        redis.call(&#39;set\&quot;,KEYS[2],now)\n&quot; +
            &quot;        redis.call(&#39;set\&quot;,KEYS[1], tokens)\n&quot; +
            &quot;        end\n&quot; +
            &quot;        end\n&quot; +
            &quot;\n&quot; +
            &quot;    if tokens &gt;= 1 then\n&quot; +
            &quot;        redis.call(&#39;set&#39;,KEYS[1],tokens -1)\n&quot; +
            &quot;        return 1\n&quot; +
            &quot;    else\n&quot; +
            &quot;        return 0\n&quot; +
            &quot;    end&quot;;

    public boolean acquire() &#123;
        Jedis jedis = jedisPool.getResource();
        try &#123;
            while (true) &#123;
                String[] keys = new String[]&#123;this.tokenKey, this.tokenKey + &quot;:time&quot;&#125;;
                String[] args = new String[]&#123;String.valueOf(capacity), String.valueOf(rate)&#125;;
                Long result = (Long) jedis.eval(script, Arrays.asList(keys), Arrays.asList(args));
                String info = String.format(&quot;tryAcquire token key=%s,tokenSize=%s result=%s&quot;, this.tokenKey, jedis.get(keys[1]), result == 1);
                if (result == 1) &#123;
                    return true;
                &#125;
            &#125;
        &#125; catch (NumberFormatException e) &#123;
            System.out.printf(String.valueOf(e));
        &#125;finally &#123;
            jedis.close();
        &#125;
        return false;
    &#125;

    /**
     * 获取令牌，有超时时间
     * @param timeout
     * @return
     */

    public boolean tryAcquire(int timeout) &#123;
        Jedis jedis = jedisPool.getResource();
        try &#123;
            long tm = System.currentTimeMillis();
            while (true) &#123;
                String[] keys = new String[]&#123;this.tokenKey, this.tokenKey + &quot;:time&quot;&#125;;
                String[] args = new String[]&#123;String.valueOf(capacity), String.valueOf(rate)&#125;;
                Long result = (Long) jedis.eval(script, Arrays.asList(keys), Arrays.asList(args));
                String info = String.format(&quot;tryAcquire token key %s,tokenSize= %s result =%s&quot;, this.tokenKey, jedis.get(keys[0]), result == 1);
                if (result == 1) &#123;
                    return true;
                &#125;
            &#125;
            if ((System.currentTimeMillis() - tm) &gt; timeout * 1000L) &#123;
                String err = String.format(&quot;tryAcquire token fail key =%s,tokenSize = %s result =%s&quot;, this.tokenKey, jedis.get(keys[0]), result == 1);
                System.out.printf(err);
                return false;
            &#125;
        &#125;catch (NumberFormatException e)&#123;
            System.out.printf(String.valueOf(e));
        &#125;finally &#123;
            jedis.close();
        &#125;
        return false;
    &#125;

&#125;
</code></pre>
<p>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/12/25/java%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BB%A4%E7%89%8C%E6%A1%B6/" data-id="clqkxqmlm0001q0ug12917u9x" data-title="java实现一个简单的令牌桶" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-如何理解云原生" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/25/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E4%BA%91%E5%8E%9F%E7%94%9F/" class="article-date">
  <time class="dt-published" datetime="2023-12-25T03:50:59.000Z" itemprop="datePublished">2023-12-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/25/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E4%BA%91%E5%8E%9F%E7%94%9F/">如何理解云原生</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>云原生是一种基于云计算的软件架构和开发方法论，旨在充分发挥云计算环境的优势和特性，如弹性，可扩展性，高可用等。云原生应用程序是专门为运行在云环境中而设计的应用程序，它们充分利用云基础设施和服务提供上所提供的各种资源和功能。</p>
<p>云原生技术通常采用容器化技术（如<a target="_blank" rel="noopener" href="https://www.docker.com/">Docker</a>）进行打包和不输，使用容器编排刚跟你讲（如Kubernetes）进行管理和编排。另外，云原生应用程序还通常采用为微服务架构，将应用程序拆分为多个小型、独立部署的服务，以增强灵活性和可维护性。</p>
<p>云原生还包括敏捷开发、持续集成&#x2F;持续部署（CI&#x2F;CD）、自动化运维等现代软件开发和交付实践，以确保应用程序在云环境中的高效、稳定和可靠运行。</p>
<p>总之，云原生是一种面向云计算环境的软件开发和部署范式，旨在利用云计算的特性和优势，以构建具有弹性、可伸缩性和高可用的现代化应用程序。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/12/25/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E4%BA%91%E5%8E%9F%E7%94%9F/" data-id="clqkxqmlo0003q0ug0bqrbpc9" data-title="如何理解云原生" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-街头的诱导消费" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/24/%E8%A1%97%E5%A4%B4%E7%9A%84%E8%AF%B1%E5%AF%BC%E6%B6%88%E8%B4%B9/" class="article-date">
  <time class="dt-published" datetime="2023-12-24T08:54:50.000Z" itemprop="datePublished">2023-12-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/">生活杂记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/24/%E8%A1%97%E5%A4%B4%E7%9A%84%E8%AF%B1%E5%AF%BC%E6%B6%88%E8%B4%B9/">街头的诱导消费</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>早上带女儿去逛街，发现一个送礼物的小舞台，一看肯定有猫腻，所谓“天下没有免费的午餐”，于是全程参与观察一下。</p>
<h2 id="免费礼物吸引"><a href="#免费礼物吸引" class="headerlink" title="免费礼物吸引"></a>免费礼物吸引</h2><p>首先，一个所谓的“主持人”在推广商品吸引人流（前期没啥人，不知道开始的那个大妈是不是托），然后开始送一些纸巾，布娃娃的小东西，一直在那扔，以此吸引一些贪小便宜或者带娃的父母，效果挺显著，吸引到20来个人。</p>
<h2 id="加大筹码，送机器人或者学习机"><a href="#加大筹码，送机器人或者学习机" class="headerlink" title="加大筹码，送机器人或者学习机"></a>加大筹码，送机器人或者学习机</h2><p>接着，等人差不多了，就一直说送机器人，但一直说数量有限，就是不送（期间大约半个小时，一直送些纸巾吸引人流），最后说机器人数量不够，开始送学习机平板补充（期间打开京东说这个4000多块，我看了一下销量是1，哈哈），大家一看，学习机更有吸引力，就不关注机器人了，开始想要学习机（注意，期间主持人有意无意排斥男人，说只送妈妈，理由是妈妈是带娃的），这里我开始怀疑，妈妈是他们的目标用户。</p>
<h2 id="进一步筛选目标用户"><a href="#进一步筛选目标用户" class="headerlink" title="进一步筛选目标用户"></a>进一步筛选目标用户</h2><p>接着又说要收30块钱，这时稍微聪明点的已经反应过来了，跑了一部分。这时候主持人会说很精明的说，这个是为了筛选诚心想试用学习机的用户，30块不收取，免费送，这时候大家的戒备心又放低了。顺便抽了一个托，送了一台学习机，大家一看，气氛又热闹了。</p>
<h2 id="围猎时刻"><a href="#围猎时刻" class="headerlink" title="围猎时刻"></a>围猎时刻</h2><p>这时候，我看到有他们的工作人员已经偷偷的用胶带把这些目标用户用围起来了，主持人说是不能送了礼物就跑，你得给我拍个照。<br />然后开始套路，说这个送了担心你们不体验，要给2799的激活费用（说这个费用是课程的钱，小学到高三，期间一直强调学习机是免费的，又强调课程拿了学习机也没用），这时可能又有一两个人走了，没所谓，这些不是他的目标用户。<br />期间，又开始套路说，“刚刚走的人不诚心，我是不会送给他的”。然后随便找一个人送了学习机，这个人可能不是托，但是，注意，你拿了他的东西是走不了的，外面几个工作人员围着，又有胶带围住。<br />这时候，又开始找一个目标，比如A，忽悠你打开收款码，给2799，但是又说不用给，刚刚是测试你是否诚意，可能这时候你的戒心又放低了。<br />然后，又开始找B,说你是不是诚心，你别以为A不用给钱，我也不用你给，你打开收款码给我扫，然后又说我真扫了，这时滴的一下，这人真给了（这时你完全无法分清她是托还是真给，反正真给了钱）。<br />然后开始问A（真正的路人），你看她给了，你给不给，不给就不诚心，不诚心可以走了，A可能不给，可能给，反正不给也没所谓，大家自愿嘛，但是东西你得留下来。然后一个个问，最终肯定有人上钩。</p>
<h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>这个是否违法？报警的话，是不违法的，如果你在现场给了钱，最多退回给你，大家自愿买卖，两厢情愿，警察也没办法，所以，见仁见智，老祖宗诚不我欺，“天下没有免费的午餐”。<br />&#x3D;&#x3D; 题外，大街小巷又很多拿着充电宝骑着电动车派传单抽奖的，大家也注意啦~</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/12/24/%E8%A1%97%E5%A4%B4%E7%9A%84%E8%AF%B1%E5%AF%BC%E6%B6%88%E8%B4%B9/" data-id="clqkxqmlq0007q0ug3ltm4kgi" data-title="街头的诱导消费" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/">博客教程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%89%AB%E7%9B%B2/">扫盲</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/">数据开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/">生活杂记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0/" rel="tag">数据中台</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0/" style="font-size: 10px;">数据中台</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/02/04/%E5%B8%B8%E8%A7%81%E7%9A%84SaaS%E7%B3%BB%E7%BB%9F/">常见的SaaS系统</a>
          </li>
        
          <li>
            <a href="/2024/02/04/%E8%AE%A4%E8%AF%86Iaas%E4%B8%8EPasS/">认识Iaas与PasS</a>
          </li>
        
          <li>
            <a href="/2024/01/05/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/">费曼学习法</a>
          </li>
        
          <li>
            <a href="/2024/01/05/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/">常用的算法技巧</a>
          </li>
        
          <li>
            <a href="/2024/01/03/%E6%90%9C%E7%B4%A2%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">搜索常用技巧</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 新水<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>